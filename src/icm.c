#include "udp_server.h"
#include "evm_controller.h"
#include "icm.h"

#define NUMBER_OF_DUMMIES 127
#define PAGE_SIZE 1024
#define ENCRYPTION

// these address spaces are mapped to secure on chip memory
void *icm_raw_data_base         = (void*)0xFFFC0000ll;   // decrypted packet
void *icm_temp_storage_base     = (void*)0xFFFD0000ll;   // temporary storage
void *icm_storage_history_base  = (void*)0xFFFE0000ll;   // storage history window for dummy request generation
void *icm_config_base           = (void*)0xFFFF0000ll;   // system configuration

ICMTempStorage *icm_temp_storage= (ICMTempStorage*)0xFFFD0000ll;
ICMConfig      *icm_config      = (ICMConfig*)0xFFFF0000ll;

uint32_t icm_hash(uint256_t key) {
  uint32_t hi = *(uint32_t*)(key + 28);
  uint32_t lo = *(uint32_t*)(key + 0);
  uint32_t hash = ((hi % 1009) * 17 + lo) % 1009;
  if (hash == 1008) hash = 0;
  return hash;
}

// returns the index
// if not found, return the first invalid (empty) element
// for insertion, use this as the new index
// for query, 
uint32_t icm_find(uint256_t key) {
  uint32_t hash = icm_hash(key);
  uint32_t cnt = 0;
  for (; cnt < 1008 && icm_temp_storage->valid[hash] && memcmp(icm_temp_storage->record[hash].k, key, sizeof(uint256_t)) != 0; hash = (hash + 1) % 1008, cnt++);

  if (cnt == 1008) 
    return 1008; 
  else 
    return hash;
}

// decrypt = private key
// encrypt = public key

void icm_clear_storage() {
  icm_temp_storage->item_count = 0;
  memset(icm_temp_storage->valid, 0, sizeof(icm_temp_storage->valid));
}

void icm_set_keys(aes128_t user_aes, rsa2048_t user_pub, rsa2048_t user_mod, rsa2048_t hevm_priv, rsa2048_t hevm_mod) {
  XCsuDma_Config *config = XCsuDma_LookupConfig(XSECURE_CSUDMA_DEVICEID);
  XCsuDma_CfgInitialize(&(icm_config->csu_dma_instance), config, config->BaseAddress);
  uint32_t iv[16] = {0};

  XSecure_AesInitialize(&(icm_config->user_aes_inst), &(icm_config->csu_dma_instance), XSECURE_CSU_AES_KEY_SRC_KUP, iv, (uint32_t*)user_aes);
  XSecure_RsaInitialize(&(icm_config->user_pub_inst), user_mod, NULL, user_pub);
  XSecure_RsaInitialize(&(icm_config->hevm_priv_inst), hevm_mod, NULL, hevm_priv);
}

rsa2048_t user_mod = {0x00, 0xcd, 0x7e, 0x29, 0x0e, 0x43, 0xb2, 0x88, 0xbb, 0xf2, 0x9d, 0x2e, 0x28, 0x65, 0x02, 0xbe, 0x8c, 0xb6, 0xa6, 0x34, 0x82, 0x70, 0x96, 0x5f, 0x6e, 0xba, 0xe7, 0xd3, 0x6d, 0x53, 0x84, 0xa0, 0x23, 0x33, 0x8b, 0xd2, 0xe0, 0x05, 0x83, 0x00, 0xf8, 0x30, 0x40, 0x21, 0x85, 0xea, 0x73, 0xb1, 0x02, 0x93, 0xaf, 0xce, 0x4a, 0x3a, 0xc4, 0x42, 0xee, 0x63, 0x41, 0xe5, 0x1e, 0x67, 0x4e, 0x67, 0xcd, 0x37, 0x9e, 0x89, 0x4e, 0x3f, 0x29, 0x9a, 0x8e, 0x7d, 0xcc, 0xb5, 0x53, 0x5c, 0x1a, 0x73, 0x57, 0x12, 0xfc, 0xea, 0x88, 0x4f, 0x98, 0x82, 0x79, 0xd7, 0x5b, 0xa7, 0x1d, 0xbd, 0x12, 0x23, 0x93, 0xd0, 0x7a, 0xa9, 0xd2, 0x6d, 0xd1, 0x6a, 0xc4, 0x12, 0x15, 0xb4, 0x1e, 0xd0, 0xad, 0xa7, 0x31, 0x50, 0x5c, 0xdd, 0x6e, 0x7b, 0x08, 0x2a, 0xfc, 0x9f, 0xf3, 0xc1, 0x29, 0x5e, 0xae, 0x0f, 0xd5, 0x57, 0x4a, 0x45, 0x0a, 0xe3, 0xa2, 0xfa, 0x50, 0x28, 0xb6, 0x85, 0x3f, 0x62, 0xeb, 0x9d, 0x93, 0xa3, 0xe3, 0x33, 0xce, 0x8a, 0x14, 0x1e, 0x99, 0x0b, 0x2e, 0x27, 0x68, 0xef, 0xba, 0xe9, 0x02, 0x0c, 0x67, 0x80, 0x4a, 0x0c, 0x72, 0x27, 0xd9, 0x62, 0xe3, 0x94, 0x6f, 0x23, 0x2d, 0x4d, 0x68, 0xb4, 0x5e, 0x42, 0x8b, 0x95, 0xda, 0xf5, 0x90, 0xbf, 0xf0, 0xd7, 0x3e, 0xd8, 0x7a, 0x67, 0xd3, 0xca, 0xa1, 0x56, 0xd8, 0xc6, 0x19, 0x50, 0x2e, 0x55, 0x47, 0x55, 0xa3, 0xf9, 0x3f, 0x37, 0xcf, 0xfc, 0x4d, 0x69, 0x66, 0x45, 0x3f, 0x31, 0x7b, 0x0e, 0xd3, 0xf5, 0xde, 0x01, 0x7d, 0x8a, 0xc5, 0x51, 0xd7, 0xb0, 0x28, 0x4e, 0x9f, 0xf4, 0xa1, 0xa8, 0x6a, 0x81, 0x43, 0x2e, 0x83, 0x94, 0x00, 0x62, 0x0a, 0xa7, 0xda, 0x55, 0xd1, 0x47, 0xbc, 0x13, 0xf0, 0x28, 0x78, 0x7d, 0xc4, 0x41, 0xe2, 0xfa, 0xc5, 0x96, 0xc3, 0x0b, 0xb6, 0x3d, 0x53, 0x85, 0xb4, 0x14, 0x7e, 0x0b, 0x68, 0x06, 0xe0, 0xd4, 0xd6, 0xba, 0x95, 0x5c, 0xc3, 0xdb, 0x2f, 0x51, 0xe8, 0x72, 0x19, 0xac, 0x40, 0x36, 0xca, 0x80, 0x9d, 0xa3, 0x9a, 0xf2, 0x8c, 0x42, 0xa3, 0x9b, 0xd5, 0x2d, 0xa2, 0x73, 0x6d, 0xfe, 0xa8, 0x44, 0x92, 0x98, 0x9e, 0xcf, 0x0e, 0x20, 0x72, 0x76, 0xd9, 0x02, 0xc5, 0xf3, 0x95, 0xca, 0xb0, 0xc8, 0xdc, 0xcf, 0x53, 0x8c, 0x48, 0x97, 0xc5, 0x42, 0x0f, 0xad, 0xfd, 0x21, 0xc8, 0x2d, 0xf4, 0x42, 0x6c, 0xc2, 0x15, 0x10, 0x6b, 0xe5, 0x08, 0xd0, 0x08, 0x1a, 0xf2, 0x7c, 0xae, 0x79, 0x42, 0x90, 0xc1, 0xee, 0xe6, 0xdb, 0xcf, 0xb4, 0xe1, 0x98, 0x3a, 0xd5, 0x1b, 0x0f, 0x74, 0xd7, 0x99, 0x32, 0x6f, 0x84, 0xf0, 0x81, 0x40, 0x39, 0x9a, 0x3e, 0xc7, 0x3e, 0x38, 0x6d, 0x43, 0xd1, 0x61};

rsa2048_t user_pub = {0x01, 0x00, 0x01};

rsa2048_t hevm_mod = {0x00, 0xb9, 0x37, 0x7a, 0x1f, 0xf3, 0x2f, 0x80, 0x60, 0x6a, 0x0b, 0x57, 0x8c, 0x63, 0x46, 0x5d, 0xea, 0x41, 0xb9, 0x74, 0x36, 0x07, 0x4c, 0x6d, 0x38, 0x6c, 0xd0, 0x87, 0x0e, 0xbd, 0xef, 0x36, 0x31, 0x93, 0xde, 0x93, 0x38, 0x29, 0x7b, 0xe4, 0x6b, 0x9c, 0x34, 0x26, 0xff, 0x70, 0xb5, 0xba, 0x69, 0x3f, 0x16, 0xb8, 0x37, 0xdc, 0x58, 0xc3, 0x89, 0xbf, 0x18, 0xa5, 0xe8, 0xef, 0xfc, 0x0c, 0x9f, 0xf8, 0x6e, 0x63, 0x3c, 0x80, 0x36, 0xd5, 0x43, 0x84, 0x7d, 0xe7, 0x4d, 0xc0, 0xfb, 0xde, 0x7a, 0x5c, 0x03, 0x12, 0xa2, 0x66, 0x03, 0xea, 0xe4, 0x9f, 0x96, 0xce, 0xa5, 0x9f, 0x2c, 0x71, 0xce, 0x75, 0xce, 0xd1, 0xb6, 0xc2, 0x7c, 0x4d, 0x2f, 0xba, 0x65, 0x1d, 0x73, 0x84, 0x05, 0x8a, 0x8a, 0x9e, 0xef, 0x50, 0xbd, 0x22, 0xd1, 0xf0, 0x1a, 0x2b, 0xf7, 0x3d, 0x58, 0x8f, 0xc6, 0x65, 0x47, 0x53, 0x2e, 0x44, 0x2f, 0xb8, 0xd0, 0x4f, 0x67, 0x53, 0xe8, 0x91, 0xa6, 0xad, 0x79, 0x1c, 0x2d, 0xfc, 0x02, 0x11, 0xf6, 0x5f, 0xa7, 0xc6, 0xb8, 0x5c, 0x8a, 0xda, 0x49, 0xfa, 0xea, 0xdc, 0x90, 0x91, 0x38, 0xee, 0x13, 0x47, 0xc1, 0x9f, 0x29, 0x2c, 0x51, 0x03, 0x16, 0x10, 0xe3, 0xc5, 0x9d, 0x97, 0x91, 0x48, 0x22, 0x5b, 0x52, 0x0d, 0x97, 0x7c, 0xd3, 0x03, 0xb3, 0x9b, 0x5f, 0x21, 0x6f, 0xe4, 0x4c, 0x81, 0x8c, 0x61, 0x5e, 0xbd, 0x53, 0x43, 0x38, 0x8a, 0xdc, 0xe7, 0x0f, 0x31, 0x69, 0xfe, 0xa7, 0x82, 0x03, 0x8e, 0x1b, 0x94, 0x4c, 0x47, 0x1a, 0x89, 0xff, 0xab, 0x02, 0xd7, 0x05, 0xc4, 0xc1, 0xfa, 0xb5, 0x93, 0xd1, 0x01, 0x9b, 0x52, 0x43, 0xc7, 0x72, 0xc9, 0x04, 0xda, 0x01, 0xc2, 0x29, 0x0c, 0x92, 0x55, 0xfa, 0xb4, 0xcc, 0x39, 0x02, 0x45, 0x72, 0x34, 0x73, 0x14, 0x6d, 0x75, 0x40, 0x45, 0xf6, 0x0c, 0x4f, 0x1a, 0x51, 0x91, 0x1b, 0x57, 0x96, 0x4b, 0x17, 0xaf, 0x03, 0x5e, 0xbb, 0xa2, 0xb0, 0xe0, 0x95, 0xdb, 0x0f, 0x11, 0x99, 0x1d, 0x60, 0x9f, 0x32, 0x5a, 0xe8, 0xc3, 0x0f, 0x54, 0xa3, 0x2a, 0xdf, 0x45, 0x29, 0x85, 0x55, 0xf2, 0x10, 0x50, 0x27, 0xb2, 0xc8, 0x76, 0x33, 0x4e, 0xe6, 0x4b, 0x3a, 0x43, 0x50, 0xa2, 0x78, 0xd7, 0x92, 0x05, 0x69, 0x43, 0x31, 0x54, 0x79, 0xf6, 0x2a, 0x3e, 0xdf, 0x8c, 0xb7, 0x0d, 0xb3, 0x2a, 0xc5, 0x3f, 0x3d, 0x54, 0x15, 0x99, 0x01, 0x3e, 0x44, 0x21, 0xf7, 0xcd, 0x81, 0xf2, 0x1c, 0xf9, 0x7b, 0xe1, 0xdf, 0x36, 0x95, 0xeb, 0x79, 0x8f, 0x87, 0xe6, 0x63, 0xaf, 0x07, 0xf4, 0xab, 0xe9, 0x64, 0x85, 0xb6, 0x2b, 0xac, 0x6b, 0x8a, 0xb1, 0x94, 0x1a, 0x06, 0x49, 0xa0, 0x9b, 0xf6, 0x61, 0x2b, 0x83, 0xd5, 0x5e, 0x95};

rsa2048_t hevm_priv = {0x5d, 0x7b, 0xa8, 0xc2, 0x33, 0x86, 0x08, 0x2f, 0xa1, 0x96, 0x73, 0xeb, 0xc1, 0xb7, 0xa4, 0x73, 0x36, 0x15, 0x1a, 0x98, 0xa2, 0x7a, 0x6a, 0xae, 0x0e, 0x0d, 0xf9, 0xfc, 0xf0, 0xd4, 0xa9, 0xef, 0xc0, 0x08, 0x99, 0x19, 0xc1, 0xa6, 0x6c, 0x95, 0xfb, 0xd3, 0x3e, 0xd3, 0xb2, 0xd9, 0xa6, 0x6a, 0xb4, 0x93, 0x0d, 0x0b, 0xf4, 0xc5, 0x40, 0x7c, 0x67, 0xdd, 0x52, 0xf0, 0x0d, 0x20, 0x94, 0x66, 0xb1, 0x87, 0x55, 0xc3, 0x15, 0x9b, 0x97, 0x6c, 0x6a, 0x94, 0xf9, 0x87, 0xff, 0x1d, 0xa1, 0x1e, 0xf5, 0x0d, 0xff, 0xfb, 0xc3, 0xad, 0xba, 0x83, 0x06, 0x21, 0xa1, 0xcf, 0x6a, 0x55, 0x8e, 0x63, 0x7c, 0x86, 0x94, 0xc6, 0xbf, 0xc6, 0xe9, 0x56, 0x6b, 0xa7, 0xd9, 0x83, 0x92, 0x61, 0x11, 0x9a, 0x01, 0xba, 0x1c, 0x70, 0x3a, 0x00, 0xe8, 0x44, 0xed, 0x67, 0xee, 0xa8, 0xa2, 0x78, 0xaa, 0x69, 0xa3, 0x8c, 0x38, 0x92, 0x35, 0x9f, 0xbe, 0x54, 0x12, 0xbf, 0xd1, 0xb3, 0xe4, 0xde, 0xb9, 0xe0, 0x63, 0xcf, 0xcf, 0xad, 0x20, 0x7e, 0x98, 0x08, 0x39, 0x7d, 0x43, 0xcc, 0x0f, 0x3f, 0x37, 0x70, 0x28, 0x3c, 0x29, 0xbd, 0xc5, 0x7b, 0xee, 0x8f, 0x63, 0x74, 0xc8, 0x2f, 0xfc, 0xfa, 0x59, 0xa5, 0xbe, 0xf8, 0x6f, 0x06, 0x18, 0x3d, 0x83, 0xea, 0xaf, 0xef, 0xf9, 0x70, 0x4f, 0xbd, 0x66, 0x2c, 0x2c, 0x75, 0xa6, 0x9a, 0xad, 0x55, 0x9f, 0xbc, 0x0a, 0xe8, 0xa5, 0xbc, 0x42, 0xd1, 0x26, 0xe0, 0x12, 0x9c, 0xf1, 0xed, 0x9f, 0x71, 0xdb, 0x30, 0x3c, 0xc6, 0xe1, 0x82, 0x93, 0xb1, 0xe9, 0x3c, 0x66, 0xf0, 0x64, 0xb6, 0x71, 0x32, 0x4b, 0x8a, 0x28, 0xb0, 0xa8, 0x2e, 0xda, 0x10, 0x91, 0x0d, 0xc4, 0x11, 0x77, 0x88, 0x35, 0xa6, 0x57, 0x03, 0xbd, 0xe3, 0x76, 0x16, 0x12, 0xfc, 0xe9, 0x77, 0x27, 0x62, 0xd4, 0x1c, 0x03, 0x07, 0x9f, 0x25, 0x0c, 0x30, 0xf3, 0x1f, 0x17, 0x9e, 0x19, 0x25, 0x7e, 0xd2, 0x49, 0x8d, 0x38, 0xe8, 0xc1, 0x2a, 0x3b, 0x18, 0x93, 0x8e, 0x1d, 0x69, 0xd1, 0x4b, 0xd9, 0x7c, 0x52, 0xa0, 0xc4, 0x42, 0x1b, 0x69, 0xd4, 0xc2, 0x74, 0xdb, 0x0e, 0x34, 0xf8, 0x49, 0x15, 0xcf, 0x15, 0x33, 0x8b, 0x25, 0x1c, 0x07, 0x53, 0xb4, 0x55, 0xff, 0xcc, 0x85, 0x95, 0x0a, 0xc2, 0x00, 0x8a, 0x63, 0xf3, 0x47, 0xba, 0x6b, 0xc8, 0x31, 0x9c, 0x05, 0xf4, 0x13, 0x3d, 0x49, 0xc5, 0x81, 0x97, 0x99, 0x0b, 0x0d, 0x75, 0x5f, 0xcc, 0x2a, 0x40, 0x3f, 0xdc, 0x74, 0x09, 0x72, 0x50, 0x02, 0x02, 0x3b, 0xf2, 0x04, 0x8a, 0x19, 0x82, 0xf9, 0xc4, 0x65, 0xa6, 0xa4, 0x7a, 0xbf, 0x29, 0x58, 0xf5, 0xd3, 0xa3, 0x9e, 0xdf, 0x39, 0x22, 0x73, 0xed, 0x85, 0xf5, 0x4e, 0x6b, 0x01};

aes128_t user_aes = {0x20, 0xf5, 0x92, 0xa6, 0xd8, 0x1a, 0x35, 0x4d, 0x04, 0xf9, 0x15, 0xcd, 0xba, 0x1e, 0xdd, 0xe6};

void icm_init() {
  icm_set_keys(user_aes, user_pub, user_mod, hevm_priv, hevm_mod);
}

uint8_t icm_decrypt() {
  ECP *req = get_input_buffer();
  
  if (req->opcode == DEBUG) {  // only for debug mode, does not encrypt
    // do nothing
    return 1;
  }
  else {
    uint8_t *signature = req->data + req->length;
    if (req->dest == STORAGE) {
      // storage cache-miss swapping query: two phases
      // phase 0 is processed locally
      // 1. if still not found, the host will check in plaintext global storage
      // responses of dummy requests should be discarded

      if (memcmp(req->data + 4, icm_config->sload_real_key, sizeof(uint256_t))) {
        return 0;
      }

      // check merkle proof
      // TODO

      // plaintext need not decrypt
      memcpy(icm_raw_data_base, req->data, req->length);
      return 1;
    }
    else {
#ifdef ENCRYPTION
      XSecure_AesDecryptData(&(icm_config->user_aes_inst), icm_raw_data_base, req->data, req->length, NULL);
#else
      memcpy(icm_raw_data_base, req->data, req->length);
#endif
      /*
      memcpy(get_output_buffer(), "echo", 4);
      memcpy(get_output_buffer() + 4, req, sizeof(ECP) + req->length);
      build_outgoing_packet(4 + sizeof(ECP) + req->length);
      */

      // check RSA signature
      // TODO
      // XSecure_RsaPublicEncrypt(rsa_user_inst, sign_c, XSECURE_RSA_2048_KEY_SIZE, icm_temp_base);

      return 1;
    }
  }
}

void icm_encrypt(uint32_t length) {
  ECP *req = get_output_buffer();
  uint32_t content_length = length - sizeof(ECP);

  if (req->opcode == DEBUG) {  // only for debug mode, does not encrypt
    // do nothing
    build_outgoing_packet(length);
  }
  else {
    if (req->src == STORAGE) {
      if (req->opcode == COPY) {
        // storage dump: just encrypt and send

        // TODO: encrypt
#ifdef ENCRYPTION
        
#else
        memcpy(req->data, icm_raw_data_base, content_length);
#endif
        build_outgoing_packet(length);

        // also, we should send out storage records in OCM
        uint64_t count = 0, content_length = 4;
        for (uint64_t i = 0; i < 1008; i++) if (icm_temp_storage->valid[i]) {
          memcpy(req->data + content_length, &(icm_temp_storage->record[i]), 64);
          count++; content_length += 64;
          
          if (count == 16) {
            req->length = content_length;
            *(uint32_t*)req->data = count;
            build_outgoing_packet(content_length + sizeof(ECP));

            count = 0; content_length = 4;
          }
        }
        if (count != 0) {
          req->length = content_length;
          *(uint32_t*)req->data = count;
          build_outgoing_packet(content_length + sizeof(ECP));
        }
      } else {
        void *base = icm_raw_data_base;

        // before anything else
        // write the swapped-out record into OCM
        uint32_t num_of_items = *(uint32_t*)base;
        if (num_of_items) {
          uint32_t id = icm_find(base + 4);
          // TODO: OCM full swap
          if (id != 1008) {
            icm_temp_storage->valid[id] = 1;
            memcpy(&(icm_temp_storage->record[id]), base + 4, 64);
          }
          base += 4 + 64;
        }
        else
          base += 4;

        // storage cache-miss swapping query: two phases
        // 0. check in encrypted buffer inside local storage
        // the swapped-out record should always been encrypted

        uint32_t id = icm_find(base + 4);
        if (icm_temp_storage->valid[id]) {
          // found, do not send output request
          ECP res;
          res.opcode = COPY;
          res.src = HOST;
          res.dest = STORAGE;

          memcpy(icm_raw_data_base, base, 4 + 32);
          memcpy(icm_raw_data_base + 4 + 32, icm_temp_storage->record[id].v, 32);
          
          ecp(&res);

          return;
        }
        
        // 1. if still not found, generate plaintext dummy requests
        // send dummy
        // since the swapped-out record has been sent in phase 0
        // we are not sending it again, instead set output num_of_items to 0
        
        memcpy(icm_config->sload_real_key, base + 4, sizeof(uint256_t));

#ifdef ENCRYPTION
#else
        memcpy(req->data, icm_raw_data_base, content_length);
#endif
        build_outgoing_packet(length);
      }
    }
    else {
#ifdef ENCRYPTION
      XSecure_AesEncryptData(&(icm_config->user_aes_inst), req->data, icm_raw_data_base, length);
#else
      memcpy(req->data, icm_raw_data_base, content_length);
#endif
      
      // build RSA signature
      // TODO

      build_outgoing_packet(length);
    }
  }
}

void icm_generate_dummy_requests() {
  
}

void icm_record_history() {
  
}
